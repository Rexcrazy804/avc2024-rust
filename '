use adv_code_2024::*;
use anyhow::*;
use code_timing_macros::time_snippet;
use const_format::concatcp;
use itertools::Itertools;
use std::collections::{HashMap, HashSet};
use std::fs::File;
use std::io::{BufRead, BufReader};
use std::{char, isize, usize};

const DAY: &str = "11";
const INPUT_FILE: &str = concatcp!("input/", DAY, ".txt");

const TEST: &str = "";

fn main() -> Result<()> {
    start_day(DAY);

    //region Part 1
    println!("=== Part 1 ===");
    assert_eq!(36, part1(BufReader::new(TEST.as_bytes()))?);
    println!("TEST PASSED");
    let input_file = BufReader::new(File::open(INPUT_FILE)?);
    let result = time_snippet!(part1(input_file)?);
    println!("Result = {}", result);
    //endregion

    //region Part 2
    //println!("\n=== Part 2 ===");
    //assert_eq!(81, part2(BufReader::new(TEST.as_bytes()))?);
    //println!("TEST PASSED");
    //let input_file = BufReader::new(File::open(INPUT_FILE)?);
    //let result = time_snippet!(part2(input_file)?);
    //println!("Result = {}", result);
    //endregion

    Ok(())
}

fn part1<R: BufRead>(reader: R) -> Result<usize> {
    let lone_line = reader.lines().next().unwrap()?;
    let mut seed = Seed::parse(&lone_line);

    for _ in 0..25 {
        seed.blink();
    }

    let answer = seed.line.len();
    Ok(answer)
}

fn part2<R: BufRead>(reader: R) -> Result<usize> {
    todo!()
}

struct Seed {
    line: Vec<usize>,
}

impl Seed {
    fn parse(str: &str) -> Self {
        let line = str.split_whitespace().map(|x| x.parse::<usize>().expect("Invalid digit")).collect_vec();

        Self {
            line
        }
    }

    fn blink(&mut self) {
        let mut new_line: Vec<usize> = Vec::new();
        for stone in &self.line {
            let stone = *stone;
            if stone == 0 {
                new_line.push(1);
                continue
            }

            if stone.to_string().len() % 2 == 0 {
                let stone_vec = stone.to_string().chars().collect_vec();
            }

        };
    }
}
